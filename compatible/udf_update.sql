-- PostgreSQL compatible tests from udf_update
-- 84 tests

-- Role used by sqllogictest directives.
SET client_min_messages = warning;
DROP ROLE IF EXISTS testuser;
CREATE ROLE testuser LOGIN;
GRANT testuser TO postgres;
RESET client_min_messages;

-- Test 1: statement (line 1)
CREATE TABLE t (a INT PRIMARY KEY, b INT);

-- Test 2: statement (line 4)
CREATE FUNCTION f1(i INT, j INT) RETURNS RECORD AS
$$
  UPDATE t SET a = i, b = j RETURNING *;
$$ LANGUAGE SQL;

-- Test 3: query (line 10)
SELECT f1(1,1);

-- Test 4: query (line 15)
SELECT f1(1,1);

-- Test 5: statement (line 20)
INSERT INTO t VALUES (1, 2);

-- Test 6: query (line 23)
SELECT f1(1,1);

-- Test 7: query (line 28)
SELECT f1(3,4);

-- Test 8: query (line 33)
SELECT * FROM t;

-- Test 9: statement (line 38)
INSERT INTO t VALUES (1, 2),(5,6),(7,8);

-- Test 10: statement (line 41)
\set ON_ERROR_STOP 0
SELECT f1(1, 11);
\set ON_ERROR_STOP 1

-- Test 11: statement (line 44)
\set ON_ERROR_STOP 0
SELECT f1(14, 14);
\set ON_ERROR_STOP 1

-- Test 12: query (line 47)
SELECT * FROM t;

-- Test 13: statement (line 55)
CREATE FUNCTION f2(i INT, j INT) RETURNS RECORD AS
$$
  UPDATE t SET b = j WHERE a = i RETURNING *;
$$ LANGUAGE SQL;

-- Test 14: query (line 61)
SELECT f2(11,2);

-- Test 15: query (line 66)
SELECT f2(5,32);

-- Test 16: query (line 71)
SELECT f2(5,9), f2(7,11);

-- Test 17: query (line 76)
SELECT f2(x,y) FROM (VALUES (1,16),(1,17)) v(x,y);

-- Test 18: query (line 82)
SELECT * FROM t;

-- Test 19: statement (line 90)
CREATE TABLE t2 (a INT, b INT, c INT);
INSERT INTO t2 VALUES (1,2,3),(4,5,6),(7,8,9);

-- Test 20: statement (line 94)
CREATE FUNCTION f3(i INT, j INT, k INT) RETURNS SETOF RECORD AS
$$
  UPDATE t2 SET (a, b) = (i, j) WHERE b < k RETURNING *;
$$ LANGUAGE SQL;

-- Test 21: query (line 100)
SELECT * FROM f3(3, 3, 7) AS foo(a INT, b INT, c INT);

-- Test 22: statement (line 106)
CREATE TABLE t3(a) AS SELECT 1::INT;

-- Test 23: statement (line 109)
CREATE FUNCTION f4() RETURNS RECORD AS
$$
  UPDATE t3 SET a = (SELECT count(a) FROM t3) RETURNING *;
$$ LANGUAGE SQL;

-- Test 24: statement (line 115)
CREATE FUNCTION f5(i INT) RETURNS INT AS
$$
  UPDATE t3 SET a = i RETURNING *;
$$ LANGUAGE SQL;

-- Test 25: query (line 122)
SELECT f5(count(a)::INT) FROM t3;

-- Test 26: statement (line 130)
CREATE TABLE t_check(x DECIMAL(1,0) CHECK (x >= 1));

-- Test 27: statement (line 133)
INSERT INTO t_check VALUES (2);

-- Test 28: statement (line 136)
CREATE FUNCTION f_check1(d DECIMAL) RETURNS RECORD AS
$$
  UPDATE t_check SET x = d RETURNING *;
$$ LANGUAGE SQL;

-- Test 29: query (line 142)
SELECT f_check1(3.5);

-- Test 30: query (line 147)
SELECT f_check1(0.5);

-- Test 31: statement (line 152)
\set ON_ERROR_STOP 0
SELECT f_check1(0);
\set ON_ERROR_STOP 1

-- Test 32: statement (line 160)
CREATE TABLE generated_as_id_t (
  a INT UNIQUE,
  b INT GENERATED ALWAYS AS IDENTITY,
  c INT GENERATED BY DEFAULT AS IDENTITY
);

-- Test 33: statement (line 167)
INSERT INTO generated_as_id_t (a) VALUES (7), (8), (9);

-- Test 34: statement (line 170)
\set ON_ERROR_STOP 0
CREATE FUNCTION f_err(i INT, j INT) RETURNS RECORD AS
$$
  UPDATE generated_as_id_t SET b=i, c=j WHERE a > 6 RETURNING *;
$$ LANGUAGE SQL;
\set ON_ERROR_STOP 1

-- Test 35: statement (line 176)
CREATE FUNCTION f_generated_as_id(j INT) RETURNS RECORD AS
$$
  UPDATE generated_as_id_t SET b=DEFAULT, c=j WHERE a > 6 RETURNING *;
$$ LANGUAGE SQL;

-- Test 36: query (line 182)
SELECT * FROM generated_as_id_t ORDER BY a;

-- Test 37: statement (line 189)
SELECT f_generated_as_id(1+1);

-- Test 38: query (line 192)
SELECT * FROM generated_as_id_t ORDER BY a;

-- Test 39: statement (line 204)
CREATE TABLE t1_103693(k1 INT PRIMARY KEY);
INSERT INTO t1_103693 VALUES (1);
CREATE TABLE t2_103693(k2 INT PRIMARY KEY, v2 INT);
INSERT INTO t2_103693 VALUES (1, 0);

-- Test 40: statement (line 208)
CREATE FUNCTION f_103693(k INT, v INT) RETURNS INT AS
$$
  UPDATE t2_103693 SET v2 = v + 1 WHERE k2 = k2 RETURNING v2;
$$ LANGUAGE SQL;

-- Test 41: statement (line 214)
-- CockroachDB-only setting.
-- SET streamer_enabled = true;

-- Test 42: query (line 217)
SELECT f_103693(k2, v2) FROM t1_103693 INNER JOIN t2_103693 ON k1 = k2;

-- Test 43: statement (line 226)
CREATE TABLE kv (k INT PRIMARY KEY, v INT);
INSERT INTO kv VALUES (1,2), (3,4), (5,6);

-- Test 44: statement (line 230)
GRANT SELECT, UPDATE ON kv TO testuser;

-- Test 45: statement (line 233)
CREATE FUNCTION f_select_for_update(i INT) RETURNS kv AS
$$
  SELECT * FROM kv WHERE k = i FOR UPDATE;
$$ LANGUAGE SQL;

-- Test 46: statement (line 239)
CREATE FUNCTION f_update(i INT, j INT) RETURNS VOID AS
$$
  UPDATE kv SET v = j WHERE k = i;
$$ LANGUAGE SQL;

-- Test 47: statement (line 245)
CREATE FUNCTION f_select_and_update(i INT, j INT) RETURNS VOID AS
$$
  SELECT * FROM kv WHERE k = i FOR UPDATE;
  UPDATE kv SET v = j WHERE k = i;
$$ LANGUAGE SQL;

-- Test 48: statement (line 252)
SELECT f_select_and_update(1,1);

-- Test 49: query (line 255)
SELECT * FROM kv;

-- Test 50: statement (line 262)
BEGIN; SELECT * FROM kv WHERE k = 3 FOR UPDATE;

-- Test 51: statement (line 265)
SELECT f_update(3,3);

-- Test 52: statement (line 268)
END;

-- Test 53: query (line 271)
SELECT * FROM kv;

-- Test 54: statement (line 278)
BEGIN; SELECT * FROM kv WHERE k = 5 FOR UPDATE;

-- Test 55: statement (line 281)
SELECT f_update(5,5);

-- Test 56: statement (line 284)
ROLLBACK;

-- Test 57: query (line 287)
SELECT * FROM kv;

-- Test 58: statement (line 294)
BEGIN;

-- Test 59: statement (line 297)
SELECT f_select_for_update(5);

-- sqllogictest: user testuser

-- Test 60: statement (line 302)
SET ROLE testuser;

SET statement_timeout = '10ms';

-- Test 61: query (line 307)
SELECT * FROM kv WHERE k = 5 FOR UPDATE;

-- statement ok
SET statement_timeout = 0;

RESET ROLE;
-- sqllogictest: user root

-- statement ok
SELECT f_update(5,5);

-- statement ok
END;

-- query II rowsort
SELECT * FROM kv;

-- Test 62: statement (line 332)
CREATE TABLE t146414 (
  a INT NOT NULL,
  b INT GENERATED ALWAYS AS (a + 1) STORED
);

-- Test 63: statement (line 338)
CREATE FUNCTION f146414() RETURNS INT LANGUAGE SQL AS $$
  UPDATE t146414 SET a = a + 1 WHERE a = 1 RETURNING b;
  SELECT 1;
$$;

-- Test 64: statement (line 344)
ALTER TABLE t146414 DROP COLUMN b;

-- Test 65: statement (line 347)
\set ON_ERROR_STOP 0
SELECT f146414();
\set ON_ERROR_STOP 1

-- Test 66: statement (line 355)
CREATE TABLE table_drop (
  a INT NOT NULL,
  b INT NOT NULL,
  c INT NOT NULL,
  d INT GENERATED ALWAYS AS (a + b) STORED
);
CREATE INDEX i ON table_drop (b);
INSERT INTO table_drop VALUES (1,2,3), (4,5,6), (7,8,9);

-- Test 67: statement (line 366)
DROP FUNCTION f_update(INT, INT);
CREATE FUNCTION f_update() RETURNS INT LANGUAGE SQL AS $$
  UPDATE table_drop SET b = b + 1 WHERE a = 1;
  SELECT 1;
$$;

-- Test 68: statement (line 373)
DROP INDEX i;

-- Test 69: statement (line 376)
ALTER TABLE table_drop DROP COLUMN d;

-- Test 70: statement (line 379)
ALTER TABLE table_drop DROP COLUMN c;

-- Test 71: statement (line 382)
ALTER TABLE table_drop DROP COLUMN b;

-- Test 72: statement (line 385)
ALTER TABLE table_drop DROP COLUMN a;

-- Test 73: statement (line 393)
CREATE TABLE t158898 (col1 INT8 NOT NULL);

-- Test 74: statement (line 396)
CREATE OR REPLACE PROCEDURE p158898() LANGUAGE PLpgSQL AS $proc$
  BEGIN UPDATE t158898 SET col1 = 1; END;
$proc$;

-- Test 75: statement (line 401)
ALTER TABLE t158898 DROP COLUMN col1;

-- Test 76: statement (line 404)
DROP PROCEDURE p158898;
DROP TABLE t158898;

-- Test 77: statement (line 413)
CREATE TABLE t158154 (col1 INT8 NOT NULL, col2 TIMESTAMP NOT NULL, computed TIMESTAMP GENERATED ALWAYS AS (col2) STORED);
INSERT INTO t158154 (col1, col2) VALUES (1, '2024-01-01');

-- Test 78: statement (line 417)
CREATE OR REPLACE PROCEDURE p158154() LANGUAGE PLpgSQL AS $proc$
  BEGIN UPDATE t158154 SET col1 = col1 + 1; END;
$proc$;

-- Test 79: statement (line 422)
CALL p158154();

-- Test 80: query (line 425)
SELECT * FROM t158154;

-- Test 81: statement (line 430)
ALTER TABLE t158154 DROP COLUMN computed, DROP COLUMN col2;

-- Test 82: statement (line 433)
CALL p158154();

-- Test 83: query (line 436)
SELECT * FROM t158154;

-- Test 84: statement (line 441)
DROP PROCEDURE p158154;
DROP TABLE t158154;

SET client_min_messages = warning;

-- PostgreSQL compatible tests from orms
-- 29 tests
--
-- The original CockroachDB suite contains a grab-bag of ORM-oriented catalog
-- queries. This PostgreSQL-adapted version creates a small schema and runs a
-- representative subset of those catalog queries using PG system catalogs.

-- Test 1: statement (setup)
DROP TABLE IF EXISTS b CASCADE;
DROP TABLE IF EXISTS a CASCADE;
DROP TABLE IF EXISTS customers CASCADE;
DROP TABLE IF EXISTS c CASCADE;
DROP TABLE IF EXISTS metatest CASCADE;
DROP TABLE IF EXISTS efcore_identity_test CASCADE;
DROP TABLE IF EXISTS src CASCADE;
DROP TABLE IF EXISTS dst CASCADE;
DROP TYPE IF EXISTS my_enum CASCADE;

CREATE TYPE my_enum AS ENUM ('x', 'y');

CREATE TABLE a (
  id INT PRIMARY KEY,
  note TEXT DEFAULT 'n/a'::text
);

CREATE TABLE b (
  id INT,
  a_id INT,
  FOREIGN KEY (a_id) REFERENCES a (id)
);

CREATE TABLE customers (
  name TEXT PRIMARY KEY,
  age INT
);
INSERT INTO customers VALUES ('jordan', 12), ('cuong', 13);

CREATE INDEX b_idx ON b(a_id);

CREATE TABLE c (a INT, b INT, PRIMARY KEY (a, b));

CREATE TABLE metatest (a INT PRIMARY KEY);
COMMENT ON COLUMN metatest.a IS 'a column';

CREATE TABLE efcore_identity_test (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY,
  CONSTRAINT pk_testtable PRIMARY KEY (id)
);

CREATE TABLE dst (a int primary key, b int);
CREATE TABLE src (c int primary key, d int references dst(a));

-- Test 2: query (columns metadata)
SELECT a.attname,
       format_type(a.atttypid, a.atttypmod) AS data_type,
       pg_get_expr(d.adbin, d.adrelid) AS default_expr,
       a.attnotnull AS not_null
FROM pg_attribute a
LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum
WHERE a.attrelid = 'a'::regclass
  AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum;

-- Test 3: query (enums)
SELECT t.typname AS enum_name,
       array_agg(e.enumlabel ORDER BY e.enumsortorder) AS enum_values
FROM pg_type t
JOIN pg_enum e ON t.oid = e.enumtypid
JOIN pg_namespace n ON n.oid = t.typnamespace
WHERE n.nspname = 'public'
GROUP BY t.typname
ORDER BY t.typname;

-- Test 4: query (indexes)
SELECT i.relname AS name,
       ix.indisprimary AS is_primary,
       ix.indisunique AS is_unique,
       pg_get_indexdef(ix.indexrelid) AS definition
FROM pg_class t
JOIN pg_index ix ON t.oid = ix.indrelid
JOIN pg_class i ON i.oid = ix.indexrelid
WHERE t.relname = 'customers'
ORDER BY i.relname;

-- Test 5: query (foreign keys)
SELECT t2.oid::regclass::text AS to_table,
       c.conname AS name,
       c.confupdtype AS on_update,
       c.confdeltype AS on_delete
FROM pg_constraint c
JOIN pg_class t1 ON c.conrelid = t1.oid
JOIN pg_class t2 ON c.confrelid = t2.oid
WHERE c.contype = 'f'
  AND t1.relname = 'b'
ORDER BY c.conname;

-- Test 6: query (regtype oids)
SELECT 'numeric'::regtype::oid AS numeric_oid;
SELECT 'character varying'::regtype::oid AS varchar_oid;

-- Test 7: query (composite primary key columns)
SELECT a.attname
FROM (
  SELECT indrelid, indkey, generate_subscripts(indkey, 1) AS idx
  FROM pg_index
  WHERE indrelid = 'c'::regclass AND indisprimary
) AS i
JOIN pg_attribute AS a ON a.attrelid = i.indrelid AND a.attnum = i.indkey[i.idx]
ORDER BY i.idx;

-- Test 8: query (identity columns)
SELECT attname, attidentity::text AS attidentity
FROM pg_attribute
WHERE attrelid = 'efcore_identity_test'::regclass
  AND attnum > 0 AND NOT attisdropped
ORDER BY attnum;

RESET client_min_messages;

